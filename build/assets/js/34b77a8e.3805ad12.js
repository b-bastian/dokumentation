"use strict";(self.webpackChunkdoku=self.webpackChunkdoku||[]).push([[1138],{6992:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var t=i(4848),s=i(8453);const r={date:new Date("2024-05-02T00:00:00.000Z"),icon:"browser",order:1e5,title:"Design Patterns"},o="Design Patterns",a={id:"SE/design-patterns",title:"Design Patterns",description:"Prinzipien objektorientierten Designs sind Prinzipien, die zu gutem objektorientierten Design f\xfchren sollen. Viele Techniken der Objektorientierung wie Entwurfsmuster, Domain-driven Design oder Dependency Injection basieren auf diesen Prinzipien objektorientierten Designs.",source:"@site/docs/SE/design-patterns.md",sourceDirName:"SE",slug:"/SE/design-patterns",permalink:"/docs/SE/design-patterns",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/SE/design-patterns.md",tags:[],version:"current",frontMatter:{date:"2024-05-02T00:00:00.000Z",icon:"browser",order:1e5,title:"Design Patterns"},sidebar:"tutorialSidebar",previous:{title:"Anforderungsanalyse",permalink:"/docs/SE/anforderungsanalyse"},next:{title:"Dokumente",permalink:"/docs/SE/dokumente"}},l={},d=[{value:"SOLID",id:"solid",level:2},{value:"<strong>S</strong>ingle Responsibility Prinzip",id:"single-responsibility-prinzip",level:3},{value:"<strong>O</strong>pen-Closed Prinzip",id:"open-closed-prinzip",level:3},{value:"<strong>L</strong>iskovsches Substitutionsprinzip",id:"liskovsches-substitutionsprinzip",level:3},{value:"<strong>I</strong>nterface Segregation Prinzip",id:"interface-segregation-prinzip",level:3},{value:"<strong>D</strong>ependency Inversion Prinzip",id:"dependency-inversion-prinzip",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"design-patterns",children:"Design Patterns"})}),"\n",(0,t.jsx)(n.p,{children:"Prinzipien objektorientierten Designs sind Prinzipien, die zu gutem objektorientierten Design f\xfchren sollen. Viele Techniken der Objektorientierung wie Entwurfsmuster, Domain-driven Design oder Dependency Injection basieren auf diesen Prinzipien objektorientierten Designs."}),"\n",(0,t.jsx)(n.p,{children:"F\xfcr eine Gruppe dieser Prinzipien wurde von Robert C. Martin das Akronym \u201cSOLID\u201d gepr\xe4gt. Diese Prinzipien gemeinsam angewandt f\xfchrt laut Robert C. Martin zu einer h\xf6heren Wartbarkeit und somit Lebensdauer von Software."}),"\n",(0,t.jsx)(n.h2,{id:"solid",children:"SOLID"}),"\n",(0,t.jsx)(n.p,{children:"Inversion, Injection"}),"\n",(0,t.jsx)(n.p,{children:'Beschreibung der einzelnen "Buchstaben", jeweils inkl. Beispiel und falls m\xf6glich einer Abbildung (muss nicht unmittelbar mit dem Beispiel zusammenh\xe4ngen - w\xe4re nat\xfcrlich besser)'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"S"}),"ingle Responsibility Prinzip"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"O"}),"pen-Closed Prinzip"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"L"}),"iskovsches Substitutionsprinzip"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"I"}),"nterface Segregation Prinzip"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"D"}),"ependency Inversion Prinzip"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"single-responsibility-prinzip",children:[(0,t.jsx)(n.strong,{children:"S"}),"ingle Responsibility Prinzip"]}),"\n",(0,t.jsxs)(n.p,{children:["F\xfcr drei verschiedene Lampentypen stehen jeweils entsprechende Funktionsbl\xf6cke (",(0,t.jsx)(n.code,{children:"FB_LampOnOff"}),", ",(0,t.jsx)(n.code,{children:"FB_LampSetDirect"})," und ",(0,t.jsx)(n.code,{children:"FB_LampUpDown"}),") zur Verf\xfcgung. Jeder Lampentyp besitzt seine eigene Funktionsweise und bietet entsprechende Methoden an, um den Ausgangswert zu ver\xe4ndern."]}),"\n",(0,t.jsxs)(n.p,{children:["Ein \xfcbergeordneter Controller (",(0,t.jsx)(n.code,{children:"FB_Controller"}),") stellt eine einheitliche Schnittstelle zur Verf\xfcgung, um auf diese drei Typen zuzugreifen. Hierbei wird das ",(0,t.jsx)(n.strong,{children:"Dependency Inversion Principle"})," angewendet, um eine feste Kopplung zwischen dem Controller und den Lampentypen zu vermeiden. Durch ",(0,t.jsx)(n.code,{children:"I_Lamp"})," wird diese einheitliche API definiert. Der abstrakte Funktionsblock ",(0,t.jsx)(n.code,{children:"FB_Lamp"})," implementiert die Schnittstelle ",(0,t.jsx)(n.code,{children:"I_Lamp"}),". Des Weiteren enth\xe4lt ",(0,t.jsx)(n.code,{children:"FB_Lamp"})," Programmcode, der bei ",(0,t.jsx)(n.strong,{children:"allen Lampentypen gleich"})," ist. Dadurch das alle Lampentypen von ",(0,t.jsx)(n.code,{children:"FB_Lamp"})," abgeleitet sind, werden ",(0,t.jsx)(n.em,{children:"Controller"})," und ",(0,t.jsx)(n.em,{children:"Lampen"})," voneinander entkoppelt. Statt Instanzen von konkreten Lampentypen anzulegen, verwaltet der Controller nur noch eine Referenz auf ",(0,t.jsx)(n.code,{children:"FB_Lamp"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://stefanhenneken.net/2022/02/20/iec-61131-3-solid-das-single-responsibility-principle/",children:"(stefanhenneken.net, 2024)"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Single Responsibility Prinzip",src:i(7145).A+"",width:"1024",height:"576"})}),"\n",(0,t.jsxs)(n.h3,{id:"open-closed-prinzip",children:[(0,t.jsx)(n.strong,{children:"O"}),"pen-Closed Prinzip"]}),"\n",(0,t.jsxs)(n.p,{children:["Inheritance is a popular method for ",(0,t.jsx)(n.strong,{children:"reusing existing function blocks"}),". It enables ",(0,t.jsx)(n.em,{children:"new methods"})," and ",(0,t.jsx)(n.em,{children:"properties"})," to be ",(0,t.jsx)(n.strong,{children:"added or existing methods overwritten"})," without requiring access to the source code for the base function block. Designing software so that it can be extended without modifying the existing code is the ",(0,t.jsx)(n.strong,{children:"key concept"})," behind the ",(0,t.jsx)(n.code,{children:"Open/Closed Principle"})," (OCP). But using inheritance also has ",(0,t.jsx)(n.em,{children:"disadvantages"}),". These disadvantages can be minimised by employing interfaces \u2013 and this is not the only advantage of this method."]}),"\n",(0,t.jsx)(n.p,{children:"To put it another way, software behaviour should be open to extension without needing to modify the software. Based on our example from my previous posts, we\u2019re going to develop a function block for managing lamp control sequences. We will then add additional functionality to extend this function block. We will use this example to illustrate the key concept underlying the Open/Closed Principle (OCP)."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://stefanhenneken.net/2023/04/06/iec-61131-3-solid-the-open-closed-principle/",children:"(stefanhenneken.net, 2024)"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Single Responsibility Prinzip",src:i(5499).A+"",width:"1024",height:"576"})}),"\n",(0,t.jsxs)(n.h3,{id:"liskovsches-substitutionsprinzip",children:[(0,t.jsx)(n.strong,{children:"L"}),"iskovsches Substitutionsprinzip"]}),"\n",(0,t.jsx)(n.p,{children:"\u201eThe Liskov Substitution Principle (LSP) requires that derived function blocks (FBs) are always compatible to their base FB. Derived FBs must behave like their respective base FB. A derived FB may extend the base FB, but not restrict it.\u201d This is the core statement of the Liskov Substitution Principle (LSP), which Barbara Liskov formulated already in the late 1980s. Although the Liskov Substitution Principle (LSP) is one of the simpler SOLID principles, its violation is very common. The following example shows why the Liskov Substitution Principle (LSP) is important."}),"\n",(0,t.jsxs)(n.p,{children:["The core of the example are three lamp types, which are mapped by the function blocks ",(0,t.jsx)(n.code,{children:"FB_LampOnOff"}),", ",(0,t.jsx)(n.code,{children:"FB_LampSetDirect"})," and ",(0,t.jsx)(n.code,{children:"FB_LampUpDown"}),". The interface ",(0,t.jsx)(n.code,{children:"I_Lamp"})," and the abstract function block ",(0,t.jsx)(n.code,{children:"FB_Lamp"})," secure a clear decoupling between the respective lamp types and the higher-level controller ",(0,t.jsx)(n.code,{children:"FB_Controller"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"FB_Controller"})," no longer accesses specific instances, but only a reference of the abstract function block ",(0,t.jsx)(n.code,{children:"FB_Lamp"}),".."]}),"\n",(0,t.jsx)(n.p,{children:"To realize the required functionality, each lamp type provides its own methods. For this reason, each lamp type also has a corresponding adapter function block (FB_LampOnOffAdapter, FB_LampSetDirectAdapter and FB_LampUpDownAdapter), which is responsible for mapping between the abstract lamp (FB_Lamp) and the concrete lamp types (FB_LampOnOff, FB_LampSetDirect and FB_LampUpDown)."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://stefanhenneken.net/2022/09/27/iec-61131-3-solid-the-liskov-substitution-principle/",children:"(stefanhenneken.net, 2024)"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Single Responsibility Prinzip",src:i(1178).A+"",width:"1024",height:"576"})}),"\n",(0,t.jsxs)(n.h3,{id:"interface-segregation-prinzip",children:[(0,t.jsx)(n.strong,{children:"I"}),"nterface Segregation Prinzip"]}),"\n",(0,t.jsx)(n.p,{children:"The basic idea of the Interface Segregation Principle (ISP) has strong similarities with the Single Responsibility Principle (SRP): Modules with too many responsibilities can negatively influence the maintenance and maintainability of a software system. The Interface Segregation Principle (ISP) focuses on the module\u2019s interface. A module should implement only those interfaces that are needed for its task. The following shows how this design principle can be implemented."}),"\n",(0,t.jsx)(n.p,{children:"The basic idea of the Interface Segregation Principle (ISP) has strong similarities with the Single Responsibility Principle (SRP): Modules with too many responsibilities can negatively influence the maintenance and maintainability of a software system. The Interface Segregation Principle (ISP) focuses on the module\u2019s interface. A module should implement only those interfaces that are needed for its task. The following shows how this design principle can be implemented."}),"\n",(0,t.jsxs)(n.p,{children:["The example extended by another lamp type (",(0,t.jsx)(n.code,{children:"FB_LampSetDirectDALI"}),"). The special feature of this lamp type is the scaling of the output value. While the other lamp types output 0-100%, the new lamp type outputs a value from 0 to 254."]}),"\n",(0,t.jsx)(n.p,{children:"Just like all other lamp types, the new lamp type (DALI lamp) has an adapter (FB_LampSetDirectDALIAdapter). The adapters have been added during the implementation of the Single Responsibility Principle (SRP) and ensure that the function blocks of the individual lamp types are only responsible for a single function (see IEC 61131-3: SOLID \u2013 The Single Responsibility Principle)."}),"\n",(0,t.jsx)(n.p,{children:"The sample program was last adapted so that the output value from the new lamp type (FB_LampSetDirectDALI) is scaled within the adapter from 0-254 to 0-100 %. This makes the DALI lamp behave exactly like the other lamp types without violating the Liskov Substitution Principle (LSP)."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://stefanhenneken.net/2023/02/25/iec-61131-3-solid-the-interface-segregation-principle/",children:"(stefanhenneken.net, 2024)"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Single Responsibility Prinzip",src:i(3952).A+"",width:"1024",height:"576"})}),"\n",(0,t.jsxs)(n.h3,{id:"dependency-inversion-prinzip",children:[(0,t.jsx)(n.strong,{children:"D"}),"ependency Inversion Prinzip"]}),"\n",(0,t.jsx)(n.p,{children:"Fixed dependencies are one of the main causes of poorly maintainable software. Certainly, not all function blocks can exist completely independently of other function blocks. After all, these interact with each other and are thus interrelated. However, by applying the Dependency Inversion Principle, these dependencies can be minimized. Changes can therefore be implemented more quickly."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://stefanhenneken.net/2022/02/09/iec-61131-3-solid-the-dependency-inversion-principle/",children:"(stefanhenneken.net, 2024)"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Single Responsibility Prinzip",src:i(695).A+"",width:"1024",height:"576"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},695:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/dependency_inversion_prinzip-f44008201abac5b068e63dd86fa70787.webp"},3952:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/interface_segregation_prinzip-b7b392f2eb6b9967f5f3c6c51ba7aaf0.webp"},1178:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/liskov_substitution_prinzip-423d964c4c239129a20d365bece14010.webp"},5499:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/open_closed_prinzip-6c51f15c17a3bc0a50a85b05ec5b76af.webp"},7145:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/single_responsibility_prinzip-fb5cbc59d15145a124514d7b92317f39.webp"},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);